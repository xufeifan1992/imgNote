## 线程



### 线程的状态

   

-------

1.线程通常有五种状态，**创建，就绪，运行，阻塞，死亡状态**

2.阻塞的情况分为三种

> 1.等待阻塞：运行的线程执行wait方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中，进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify霍notifyAll方法才能被唤醒，wait是object类的方法
>
>   
>
> 2.同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则jvm会吧该线程放入锁池中
>
>   
>
> 3.其他阻塞：运行的线程执行sleep或join方法，或者发出I/O请求时，JVM会把该线程设置为阻塞状态。当sleep状态超时，join等待线程终止或者超时，或者I/O处理完毕时，线程重新转入就绪状态，sleep是Tread类的方法

   

### 线程的生命周期

-----

1.新建状态：新创建一个线程对象

2.就绪状态：线程对象被调用后，其他线程调用了该对象的start方法，该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权

3.运行状态：就绪状态的线程获取CPU，执行程序代码

4.阻塞状态：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行，直到进入就绪状态，才有机会转到运行状态

5.死亡状态：线程执行完了或者因为异常退出了run方法，该线程生命周期结束

   

   

-----

### sleep,wait,join,yield方法的区别

  

1.锁池

所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后就会进入就绪队列进行等待cpu资源分配

  

2.等待池

当我们调用wait方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁，只有调用了notify方法或者notifyAll后等待池的线程才会去竞争锁，notify是随机从等待池选出一个线程放到锁池，而notifyAll是将等待池的所有线程放到锁池当中

-----

  

#### sleep和wait的区别

1.sleep是Thread类的静态本地方法，wait则是Object类的本地方法

2.sleep方法不会释放lock，wait方法会释放lock，而且会加入等待队列中

```java
sleep就是把cpu的执行资格和执行权释放出去，不再运行此线程，当定时是假结束后再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运行了，而如果sleep时改线程有锁，那么sleep不会释放这个锁，而是带着锁着进入冻结状态，也就是说其他需要这个锁的线程个呢本不可能获取这个锁，额就是说无法执行程序，如果睡眠期间其他线程调用了这个线程的iterrupt方法，那么这个线程就会抛出interruptexception异常返回，这点wait是一样的
```

3.sleep方法不依赖同步器synchronized，但是wait需要依赖synchronized关键字

4.sleep不需要被唤醒，但是wait需要(不指定时间需要被别人中断)

5.sleep一般不用于当前线程休眠，或者轮巡暂停操作，wait则用于多线程之间通信

6.sleep会让出cpu执行权且强制上下文切换，但是wait不一定，wait后可能还是会有机会重新竞争到锁继续执行

  

#### yield方法

执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行



#### join方法

执行后线程进入阻塞状态，例如在线程B中调用线程A的join方法，那么线程B会进入到阻塞状态，知道线程A执行结束或者中断线程

  

-----

### 对线程安全的理解

  

不是线程安全，应该是内存安全，堆是共享内存，可以被所有线程访问

> 当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的

**堆是进程和线程共有的空间，分全局堆和局部堆，全局堆就是没有分配的空间，局部堆就是用户分配的空间，堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了还要还给操作系统，要不然就是内存泄露**

> 在java中，堆是Java虚拟机锁管理的内存最大的一块，是所有线程共享的一块内存区域，在虚拟机启动时创建堆，堆所在的内存区域唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存

**栈是每个线程独有的，保存其运行状态和局部自动变量，栈在线程开始的时候初始化，每个线程的栈都是互相独立，因此，栈是线程安全的，操作系统在切换线程的时候会自动切换栈，栈空间不需要在高级语言里面显示的分配和释放**

  

目前主流操作系统都是多任务的，即多个进行同时运行，为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程，这是由操作系统保证的

  

在每个进程的内存空间都会有一块特殊的公共区域，通常称为堆，进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因



  

