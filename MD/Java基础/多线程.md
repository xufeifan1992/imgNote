## 线程



### 线程的状态

   

-------

1.线程通常有五种状态，**创建，就绪，运行，阻塞，死亡状态**

2.阻塞的情况分为三种

> 1.等待阻塞：运行的线程执行wait方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中，进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify霍notifyAll方法才能被唤醒，wait是object类的方法
>
>   
>
> 2.同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则jvm会吧该线程放入锁池中
>
>   
>
> 3.其他阻塞：运行的线程执行sleep或join方法，或者发出I/O请求时，JVM会把该线程设置为阻塞状态。当sleep状态超时，join等待线程终止或者超时，或者I/O处理完毕时，线程重新转入就绪状态，sleep是Tread类的方法

   

### 线程的生命周期

-----

1.新建状态：新创建一个线程对象

2.就绪状态：线程对象被调用后，其他线程调用了该对象的start方法，该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权

3.运行状态：就绪状态的线程获取CPU，执行程序代码

4.阻塞状态：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行，直到进入就绪状态，才有机会转到运行状态

5.死亡状态：线程执行完了或者因为异常退出了run方法，该线程生命周期结束

   

   

-----

### sleep,wait,join,yield方法的区别

  

1.锁池

所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后就会进入就绪队列进行等待cpu资源分配

  

2.等待池

当我们调用wait方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁，只有调用了notify方法或者notifyAll后等待池的线程才会去竞争锁，notify是随机从等待池选出一个线程放到锁池，而notifyAll是将等待池的所有线程放到锁池当中

  

-----

  

#### sleep和wait的区别

1.sleep是Thread类的静态本地方法，wait则是Object类的本地方法

2.sleep方法不会释放lock，wait方法会释放lock，而且会加入等待队列中

> sleep就是把cpu的执行资格和执行权释放出去，不再运行此线程，当定时结束后再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运行了，而如果sleep时该线程有锁，那么sleep不会释放这个锁，而是带着锁着进入冻结状态，也就是说其他需要这个锁的线程根本不可能获取这个锁，也就是说无法执行程序，如果睡眠期间其他线程调用了这个线程的iterrupt方法，那么这个线程就会抛出interruptException异常返回，这点wait是一样的

3.sleep方法不依赖同步器synchronized，但是wait需要依赖synchronized关键字

4.sleep不需要被唤醒，但是wait需要(不指定时间需要被别人中断)

5.sleep一般不用于当前线程休眠，或者轮巡暂停操作，wait则用于多线程之间通信

6.sleep会让出cpu执行权且强制上下文切换，但是wait不一定，wait后可能还是会有机会重新竞争到锁继续执行

  

#### yield方法

执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行



#### join方法

执行后线程进入阻塞状态，例如在线程B中调用线程A的join方法，那么线程B会进入到阻塞状态，知道线程A执行结束或者中断线程

  

-----

### 对线程安全的理解

  

不是线程安全，应该是内存安全，堆是共享内存，可以被所有线程访问

> 当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的

**堆是进程和线程共有的空间，分全局堆和局部堆，全局堆就是没有分配的空间，局部堆就是用户分配的空间，堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了还要还给操作系统，要不然就是内存泄露**

> 在java中，堆是Java虚拟机锁管理的内存最大的一块，是所有线程共享的一块内存区域，在虚拟机启动时创建堆，堆所在的内存区域唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存

**栈是每个线程独有的，保存其运行状态和局部自动变量，栈在线程开始的时候初始化，每个线程的栈都是互相独立，因此，栈是线程安全的，操作系统在切换线程的时候会自动切换栈，栈空间不需要在高级语言里面显示的分配和释放**

  

目前主流操作系统都是多任务的，即多个进行同时运行，为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程，这是由操作系统保证的

  

在每个进程的内存空间都会有一块特殊的公共区域，通常称为堆，进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因

  

----

### Thread和Runnable的区别

  

Thread和Runnable的实质是继承关系，没有可比性，无论使用Runnable还是Thread，都会new Thread，然后执行run方法，用法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简单的执行一个任务，那就实现Runnable

  

----

### 对于守护线程的理解

**守护线程：为所有非守护线程提供服务的线程，任何一个守护线程都是整个jvm中所有非守护线程的保姆**

  

**守护线程类似于整个进程的一个默默无闻的笑喽喽，他的生死无关紧要，它缺依赖整个进程而运行，哪天其他线程结束了，没有要执行的了，程序就结束了，理都没理守护线程，就把他中断了**

  

*由于守护线程的终止是自身无法控制的，因此千万不要吧IO,FILE等重要逻辑操作 分配给它*

  

#### 守护线程的作用是什么

  

举例：GC垃圾回收线程：就是一个典型的守护线程，当我们程序中不再由任何的Thread，程序就不会再产生垃圾，垃圾回收线程也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开，它始终在低级别的状态中运行，用于实时监控和管理系统中的回收资源

  

> 应用场景：1.来为其他线程提供服务支持情况
>
> ​					2.或者在任何情况下，程序结束，这个线程必须正常且立刻关闭，就可以作为守护线程来使用，反之，如果一个正在执行某个操作的线程必须要正确地关闭掉否则就会出现不好的后果的话，那么这个线程就不能是守护线程，而是用户线程，通常都是一些关键的事务，比方说，数据库录入或者更新，这些操作都是不能中断的

​    

*thread.setDaemon(true)必须在thread.start()之前设置，否则会报出IllegalThreadStateException异常，你不能吧正在运行的常规线程设置为守护线程*

  

*在Daemon线程中产生的新线程也是Daemon*

  

*守护线程不能用于去访问固有资源，比如读写操作或者计算逻辑，因为他会在任何时候甚至在一个操作中间发生中断*



*java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池*



​    

---

### ThreadLocal的原理和使用场景

  

每一个Thread对象均包含一个ThreadLocalMap类型的成员变量threadlocals,它存储本线程中所有ThreadLocal对象及其对应的值

  

ThreadLocalMap由一个个entry对象构成

  

Entry继承自weakReference<ThreadLocal<?>>,一个Entry由Object构成，由此可见，Enty的key是ThreadLocal对象，并且是一个弱引用，当没指向key的强引用后，该key就会被垃圾收集器回收

  

当执行Set方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象，再以当前ThreadLocal对象为key，将值存储金ThreadLocal对象中。

  

get方法执行过程类似，ThreadLocal首先回去当前线程对象，然后获取	当前线程的ThreadLocalMap对象，再以当前ThreadLocal对象为key，获取对应的value

  

由于每一条线程均含有各自**私有**的ThreadLocalMap容器，这些容器相互独立互不影响，因此不会出现线程安全问题，从而无需使用同步机制来保证多条线程访问容器的互斥性

  

> 使用场景：
>
> ​					1.在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递,打破层次间的约束
>
> ​					2.线程间的数据隔离
>
> ​					3.进行事务操作,用于存储线程事务信息
>
> ​					4.数据库连接,session会话管理
